"""Evaluates net performance on an experiment"""
from __future__ import division

import random
import logging

def get_error(trial):
    """Returns float: the total error of one trial

    Args:
      trial str: lens output for one trial
    """
    # lines = trial.split('\n')
    # error_line = re.search(r'Err.*', trial).group(0)
    # error = re.search(r'[0-9.]+', error_line).group(0)
    # return float(error)

    examples = trial.split('\n')[3:-1]
    try:
        errors = [float(e.split('   ')[1]) for e in examples]
    except:
        errors = [float(e.split('   ')[2]) for e in examples]
    return sum(errors)


def get_network_choices(trial_errors):
    """Returns ([int], [float]): choices and reaction time
    choices is a list of 0 or 1 corresponding to word indices in one trial
    reaction time is a list of floats

    Args:
      trial_errors [(float, float)]: each tuple represents
        the reaction times for the two words in a trial
    """
    # pairs of consecutive words correspond to trials
    

    def choose(pair):
        # p(choose word1) = error2/(error1+error2)
        threshold = pair[0]/sum(pair)
        choice =  0 if random.random() > threshold else 1
        # reaction time is inverse of percentage difference between values
        rt = 1 / (abs(pair[0]-pair[1])/(sum(pair)/2))
        return (choice, rt)

    results = [choose(p) for p in trial_errors]
    choices = [r[0] for r in results]
    reaction_times = [r[1] for r in results]
    return choices, reaction_times


def get_correct_choices():
    """Returns [int]: tuple index of correct word for each trial"""
    with open('experiment/answer-key.txt', 'r') as f:
        key = f.read()
    key = key.split('\r')
    key = map(int, key)
    return key


def test_word_choices(choices):
    """Returns [int]: indices of trials net was incorrect for

    Args:
      choices: [int] network's word choices, 1 or 0"""
    key = get_correct_choices()
    assert len(choices) == len(key)
    incorrect = []
    for i in range(len(key)):
        if choices[i] != key[i]:
            incorrect.append(i)
    return incorrect
    

def run_one(out):
    """Returns accuracy and word errors for one condition"""
    runs = out.split('***')[1:]
    errors = [get_error(run) for run in runs]
    # put errors into pairs corresponding to trials
    trial_errors = [(errors[i], errors[i+1]) for i in range(0, len(errors), 2)]
    choices, reaction_times = get_network_choices(trial_errors)
    incorrect = test_word_choices(choices)
    accuracy = 1 - (len(incorrect) / len(choices))
    correct_reaction_times = [t for i, t in enumerate(reaction_times)
                              if i not in incorrect]
    reaction = sum(correct_reaction_times) / len(correct_reaction_times)

    results = {'accuracy': accuracy,
               'reaction': reaction,
               'errors': errors,
               'all_rts': reaction_times}
    return results

def evaluate_experiment(lens_output):
    """Returns dict of net's performance on both word choice conditions

    Args:
      lens_output (str): stdout generated by experiment.in"""
    logging.debug('============================================================')
    logging.debug(lens_output)
    logging.debug('============================================================')
    with open('experiment-log.out', 'w+') as f:
        f.write(lens_output)

    A, B = map(run_one, lens_output.split('######'))

    results = {}
    for d, condition in [(A, 'contoid'), (B, 'vocoid')]:
        for k, v in d.items():
            results[condition + '_' + k] = v
    return results


if __name__ == '__main__':
    with open('experiment-log.out', 'r') as f:
        res =  evaluate_experiment(f.read())